<!DOCTYPE html><html><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Computational Algebra System in Haskell : Library to calculate Gröbner basis written in Haskell.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/syntax.css">
    <link href="./katex/katex.min.css" type="text/css" rel="stylesheet">
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      tex2jax: {inlineMath: [["\\(","\\)"]],
                displayMath: [["\\[", "\\]"]]},
      jax: ["input/TeX","output/HTML-CSS"],
      TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "https://konn.github.io/xyjax/extensions/TeX/xypic.js"] }
      });
    </script>

    <script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
    </script>

    <title>Home - Computational Algebra System in Haskell</title>
  </head>
  <body>
    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/konn/computational-algebra">View on GitHub</a>

          <h1 id="project_title">Computational Algebra System in Haskell</h1>
          <h2 id="project_tagline">Dependently-typed computational algebra system written in Haskell.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/konn/computational-algebra/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/konn/computational-algebra/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        
        <section id="toc">
        <h1>Table of Contents</h1>
        <ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#requirements-and-installation">Requirements and Installation</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#type-interface-for-polynomials-and-algebraic-structures">Type Interface for Polynomials and Algebraic Structures</a>
<ul>
<li><a href="#type-level-natural-numbers-and-singletons">Type-level natural numbers and singletons</a></li>
<li><a href="#algebraic-structures-and-operations">Algebraic structures and operations</a></li>
<li><a href="#polynomial">Polynomial</a>
<ul>
<li><a href="#abstract-type-classes-for-polynomials">Abstract type-classes for Polynomials</a></li>
<li><a href="#polynomials-and-monomial-orderings">Polynomials and Monomial Orderings</a></li>
<li><a href="#how-to-write-ismonomialorder-instances">How to write <code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code> instances?</a></li>
</ul></li>
<li><a href="#variants-of-polynomial-types">Variants of polynomial types</a></li>
<li><a href="#other-polynomial-operations">Other polynomial operations</a></li>
</ul></li>
<li><a href="#provided-algebraic-structures">Provided Algebraic Structures</a>
<ul>
<li><a href="#finite-fields">Finite Fields</a>
<ul>
<li><a href="#galois-field-computation-with-arbitrary-irreducible-polynomials">Galois Field computation with arbitrary irreducible polynomials</a></li>
</ul></li>
<li><a href="#quotient-rings">Quotient rings</a></li>
<li><a href="#algebraic-reals">Algebraic Reals</a></li>
</ul></li>
<li><a href="#links">Links</a>
<ul>
<li><a href="#publication">Publication</a></li>
</ul></li>
</ul>
        </section>
        
        <h2 id="overview">Overview</h2>
<p>The <code>computational-algebra</code> is the computational algebra system, implemented as a Embedded Domain Specific Language (<em>EDSL</em>) in <a href="https://www.haskell.org">Haskell</a>.
This library provides many functionality for computational algebra, especially ideal computation such as Groebner basis calculation.</p>
<p>Thanks to Haskell’s powerful language features, this library achieves the following goals:</p>
<dl>
<dt>Type-Safety</dt>
<dd>Haskell’s static type system enforces <strong>static correctness</strong> and prevents you from violating invariants.
</dd>
<dt>Flexibility</dt>
<dd>With the powerful type-system of Haskell,
we can write <strong>highly abstract program</strong> resulted in <strong>easy-to-extend</strong> system.
</dd>
<dt>Efficiency</dt>
<dd>Haskell comes with many <strong>aggressive optimization mechanism</strong> and <strong>parallel computation features</strong>,
which enables us to write efficient program.
</dd>
</dl>
<p>This package currently provides the following functionalities:</p>
<ul>
<li>Groebner basis calculation w.r.t. arbitrary monomial ordering
<ul>
<li>Currently using Buchberger’s algorithm with some optimization</li>
<li>Faugere’s <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">F_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="base"><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathit">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span></span></span></span></span></span> algorithms is experimentally implemented,
but currently not as fast as Buchberger’s algorithm</li>
</ul></li>
<li>Computation in the (multivariate) polynomial ring over arbitarary field and its quotient ring
<ul>
<li>Ideal membership problem</li>
<li>Ideal operations such as intersection, saturation and so on.</li>
<li>Zero-dimensional ideal operation and conversion via FGLM algorithm</li>
<li>Variable elimination</li>
</ul></li>
<li>Find numeric solutions for polynomial system with real coefficient</li>
</ul>
<h2 id="requirements-and-installation">Requirements and Installation</h2>
<p>Old version of this package is <a href="http://hackage.haskell.org/package/computational-algebra">uploaded on Hackage</a>, but it’s rather outdated.
Most recent version of <code>computational-algebra</code> is developed on <a href="https://github.com/konn/computational-algebra">GitHub</a>.</p>
<p>It uses the most agressive language features recently implemented in <a href="https://www.haskell.org/ghc/">Glasgow Haskell Compiler</a>, so it requires at least GHC 8.0.1 and
also it depends on many packages currently not available on Hackage, but you can install it fairly easily with help of <a href="https://docs.haskellstack.org/en/stable/README/">The Haskell Tool Stack</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>$ curl -sSL https://get.haskellstack.org/ <span class="kw">|</span> sh</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># if you haven't install Stack yet</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>$ git <span class="kw">clone</span> https://github.com/konn/computational-algebra</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>$ <span class="kw">cd</span> computational-algebra</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>$ stack build</span></code></pre></div>
<p>In addition, you may need to install GSL and LAPACK (for matrix computation) beforehand.
You can install them via Homebrew (OS X), <code>apt-get</code>, or other major package management systems.</p>
<h2 id="example">Example</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds, DataKinds, GADTs, KindSignatures     #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses, NoImplicitPrelude              #-}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoMonomorphismRestriction, QuasiQuotes, TypeOperators #-}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Algebra.Algorithms.Groebner</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Algebra.Field.Finite</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Algebra.Prelude</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Ordinal.Builtin</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | 0-th variable of polynomial ring with at least one variable.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Variables are 0-origin.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">CoeffRing</span> r, <span class="dt">IsMonomialOrder</span> n order, (<span class="dv">0</span> <span class="op">:&lt;</span> n) <span class="op">~</span> <span class="dt">'True</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">OrderedPolynomial</span> r order n</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> var [od|0|]</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- | 1-st variable of polynomial ring with at least two variable.</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="ot">y ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">CoeffRing</span> r, <span class="dt">IsMonomialOrder</span> n order, (<span class="dv">1</span> <span class="op">:&lt;</span> n) <span class="op">~</span> <span class="dt">'True</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">OrderedPolynomial</span> r order n</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> var [od|1|]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- | The last variable of</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="ot">z ::</span> <span class="dt">Polynomial</span> <span class="dt">Rational</span> <span class="dv">3</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> var [od|2|]</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- | f in QQ[x,y,z]</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="dv">3</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="dv">1</span><span class="op">%</span><span class="dv">2</span><span class="op">*</span>x<span class="op">*</span>y<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- | map f to the F_5[x,y,z], where F_5 = ZZ/5ZZ</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="ot">f' ::</span> <span class="dt">Polynomial</span> (<span class="dt">F</span> <span class="dv">5</span>) <span class="dv">3</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>f' <span class="ot">=</span> mapCoeff (\r <span class="ot">-&gt;</span> <span class="fu">fromInteger</span> (<span class="fu">numerator</span> r) <span class="op">/</span> <span class="fu">fromInteger</span> (<span class="fu">denominator</span> r) ) f</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- | ideal of QQ[x,y,a,b,c,s]</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="ot">heron ::</span> <span class="dt">Ideal</span> (<span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Lex</span> <span class="dv">6</span>)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>heron <span class="ot">=</span> toIdeal [ <span class="dv">2</span> <span class="op">*</span> s <span class="op">-</span> a <span class="op">*</span> y</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                , b<span class="op">^</span><span class="dv">2</span> <span class="op">-</span> (x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>                , c<span class="op">^</span><span class="dv">2</span> <span class="op">-</span> ((a <span class="op">-</span> x)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                ]</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | Get the last four variables of QQ[x,y,a,b,c,s]</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    [_, _, a, b, c, s] <span class="ot">=</span> vars</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> f</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> f'</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> x <span class="op">*</span> f'<span class="op">^</span><span class="dv">2</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> calcGroebnerBasis heron</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- print $ f' * 5 + f -- ^ Type error!</span></span></code></pre></div>
<h2 id="type-interface-for-polynomials-and-algebraic-structures">Type Interface for Polynomials and Algebraic Structures</h2>
<p><code>computational-algebra</code> provides well-typed interface. In this section, we will see how this package represents mathematical objects by type.</p>
<h3 id="type-level-natural-numbers-and-singletons">Type-level natural numbers and singletons</h3>
<p>As we will see below, we use type-level natural number to indicate the number of variables. So, let’s see how we express natural numbers as type.</p>
<p>The <a href="http://hackage.haskell.org/package/type-natural"><code>type-natural</code> package</a> provides the functionality to treat type-level natural numbers seamlesly.
That library also provides Peano numerals, but it is enough to use <code>*.Builtin</code> module for our purposes.</p>
<p>Sometimes we have to specify the type-level natural as function argument explicitly. We use so-called <strong>singleton</strong>s for the type natural in such case.
To generate singletons for type-level naturals, we can use <code class="sourceCode haskell">snat</code> quasiquoter from <code class="sourceCode haskell"><span class="dt">Data.Type.Natural.Builtin</span></code> in <code>type-natural</code> package.
Furthermore, the <a href="http://hackage.haskell.org/package/singletons"><code>singletons</code> package</a> provides unified way to do with singletons.
For more detail, please read the <a href="http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf">original paper of singletons</a>.</p>
<p>For technical reason, the compiler must know the information of specific type-level natural number.
This constraint is expressed as the type-class<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat"><code class="sourceCode haskell"><span class="dt">KnownNat</span> n</code></a> from <code class="sourceCode haskell"><span class="dt">GHC.TypeLits</span></code> module, where <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span> is type-level natural.
It seems rather noisy to have these constraints all around, but if we have singleton value <code class="sourceCode haskell"><span class="ot">sn ::</span> <span class="dt">SNat</span> n</code> for some <code class="sourceCode haskell">n</code>, then we can give such information to the compiler by <a href="http://hackage.haskell.org/package/singletons/docs/Data-Singletons-TypeLits.html#v:withKnownNat"><code class="sourceCode haskell">withKnownNat</code></a> from <a href="http://hackage.haskell.org/package/singletons/docs/Data-Singletons-TypeLits.html"><code class="sourceCode haskell"><span class="dt">Data.Singletons.TypeLits</span></code></a> of <code>singletons</code> package:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Singletons.TypeLits</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">func ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="op">...</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">caller ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="op">...</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>caller sn <span class="ot">=</span> withKnownNat n <span class="op">$</span> func <span class="op">...</span></span></code></pre></div>
<h3 id="algebraic-structures-and-operations">Algebraic structures and operations</h3>
<p>To express algebraic structures, we use the type classes from <a href="http://hackage.haskell.org/package/algebra"><code>algebra</code></a> package.
For example, if we say “k is a <em>field</em>”, it means that <code class="sourceCode haskell">k</code> is an instance of <code class="sourceCode haskell"><span class="dt">Field</span></code> class from <code>algebra</code> package.
As mentioned above, we can compute the Groebner basis for ideals in polynomial rings over arbitary field. This means we can compute bases for those with coefficient field an instance of <code>Field</code>.</p>
<p>The ring and field operations for objects implemented in this package is provided as the instance function of <code class="sourceCode haskell"><span class="dt">Ring</span></code> and <code class="sourceCode haskell"><span class="dt">Field</span></code> classes.
Of course, this package also provides instances for the standard type classes such as <code class="sourceCode haskell"><span class="dt">Num</span></code> and <code class="sourceCode haskell"><span class="dt">Fractional</span></code>, but we recommend to use the operation from <code>algebra</code> with <code class="sourceCode haskell"><span class="dt">NoImplicitPrlude</span></code> option. We provide the convenient module <a href="./docs/computational-algebra-0.6.0.0/Algebra-Prelude.html"><code class="sourceCode haskell"><span class="dt">Algebra.Prelude</span></code></a> to use with <code class="sourceCode haskell"><span class="dt">NoImplicitPrlude</span></code> option.</p>
<h3 id="polynomial">Polynomial</h3>
<p>The type for the polynomials and operations are defined in <a href="./docs/computational-algebra-0.6.0.0/Algebra-Ring-Polynomial.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial</span></code></a> module.</p>
<p><a href="docs/halg-polynomials-0.6.0.0/Algebra-Ring-Polynomial.html#t:OrderedPolynomial"><code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> r <span class="fu">ord</span> n</code></a> represents</p>
<ul>
<li>the <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span>-variate polynomial ring,</li>
<li>over the coefficient ring <code class="sourceCode haskell">r</code>,</li>
<li>with terms sorted w.r.t. <a href="http://en.wikipedia.org/wiki/Monomial_order"><em>the monomial ordering</em></a> <code class="sourceCode haskell"><span class="fu">ord</span></code>.</li>
</ul>
<p>In the above, <code class="sourceCode haskell">n</code> should have kind <code class="sourceCode haskell"><span class="dt">Nat</span></code> and <code class="sourceCode haskell">r</code> should be at least an instance of <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#t:CoeffRing"><code class="sourceCode haskell"><span class="dt">CoeffRing</span></code></a>, which is essentially equivalent to “Commutative Ring with decidable equality”, but usually the <a href="docs/algebra-4.3/Numeric-Field-Class.html#t:Field"><code class="sourceCode haskell"><span class="dt">Field</span></code></a> for practical usage. The monomial ordering <code class="sourceCode haskell"><span class="fu">ord</span></code> should be the instance of <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsMonomialOrder"><code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code></a>.
More precisely, <code class="sourceCode haskell"><span class="fu">ord</span></code> must have instance for <code class="sourceCode haskell"><span class="dt">IsMonomial</span> <span class="dt">Order</span> n <span class="fu">ord</span></code> if and only if <code class="sourceCode haskell"><span class="fu">ord</span></code> stands for some monomial ordering on n-ary polynomial.</p>
<p>Let’s see example. <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">Q</mi></mrow><mo>[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Q}[x,y,z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span class="mord"><span class="mord mathbb">Q</span></span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mpunct">,</span><span style="margin-right: 0.03588em;" class="mord mathit">y</span><span class="mpunct">,</span><span style="margin-right: 0.04398em;" class="mord mathit">z</span><span class="mclose">]</span></span></span></span></span></span> (the trivariate polynomial ring over the rational number) with Lex ordering is represented by the type <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Lex</span> <span class="dv">3</span></code>. <code class="sourceCode haskell"><span class="dt">Polynomial</span> <span class="dt">Rational</span> <span class="dv">3</span></code> is short for <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="dv">3</span></code>.</p>
<h4 id="abstract-type-classes-for-polynomials">Abstract type-classes for Polynomials</h4>
<p>Sometimes, one might want to use different implementation for polynomials optimized to specific task.
For such a purpose, we provide two abstract type-classes <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#t:IsPolynomial"><code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code></a> and <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#t:IsOrderedPolynomial"><code class="sourceCode haskell"><span class="dt">IsOrderedPolynomial</span></code></a>, defined in <a href="./docs/computational-algebra-0.6.0.0/Algebra-Ring-Polynomial-Class.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Class</span></code></a> module.
Indeed, many algebraic operations for <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span></code> are provided via these classes.</p>
<p>The first <code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code> class abstracts polynomial rings by the universality offree commutative algebra over commutative ring.
The instance <code class="sourceCode haskell"><span class="dt">IsPolynomial</span> poly</code> means “<code class="sourceCode haskell">poly</code> is a polynomial ring”.
The class comes with two associated types: <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#t:Arity"><code class="sourceCode haskell"><span class="dt">Arity</span></code></a> and <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#t:Coefficient"><code class="sourceCode haskell"><span class="dt">Coefficient</span></code></a>.
For example, we have the following instance for <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span></code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">CoeffRing</span> r, <span class="dt">IsMonomialOrder</span> n <span class="fu">ord</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> <span class="dt">IsPolynomial</span> (<span class="dt">OrderedPolynomial</span> r <span class="fu">ord</span> n) <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Arity</span> (<span class="dt">OrderedPolynomial</span> r <span class="fu">ord</span> n) <span class="ot">=</span> n</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Coefficient</span> (<span class="dt">OrderedPolynomial</span> r <span class="fu">ord</span> n) <span class="ot">=</span> r</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>As their name indicates, <code class="sourceCode haskell"><span class="dt">Arity</span> poly</code> stands for the <em>arity</em> of <code class="sourceCode haskell">poly</code>, that is, the number of variables of <code class="sourceCode haskell">poly</code> and <code class="sourceCode haskell"><span class="dt">Coefficient</span> poly</code> stands for the coefficient ring of <code class="sourceCode haskell">poly</code>.
The essential class functions of it is <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:var"><code class="sourceCode haskell">var</code></a> and <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:liftMap"><code class="sourceCode haskell">liftMap</code></a>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IsPolynomial</span> poly <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  var     ::</span> <span class="dt">Ordinal</span> (<span class="dt">Arity</span> poly) <span class="ot">-&gt;</span> poly</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  liftMap ::</span> (<span class="dt">Module</span> (<span class="dt">Scalar</span> (<span class="dt">Coefficient</span> poly)) alg,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Ring</span> alg, <span class="dt">Commutative</span> alg)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>          <span class="ot">=&gt;</span> (<span class="dt">Ordinal</span> (<span class="dt">Arity</span> poly) <span class="ot">-&gt;</span> alg) <span class="ot">-&gt;</span> poly <span class="ot">-&gt;</span> alg</span></code></pre></div>
<p><code class="sourceCode haskell">var n</code> stands for the <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span>-th variable of poly.
The type <code class="sourceCode haskell"><span class="dt">Ordinal</span> n</code> is provided in <a href="http://hackage.haskell.org/package/type-natural/docs/Data-Type-Ordinal-Builtin.html"><code class="sourceCode haskell"><span class="dt">Data.Type.Ordinal.Builtin</span></code></a> of <code>type-natural</code> package, and it stands for the natural numbers less than n.
So, in the context of polynomial, you can think <code class="sourceCode haskell"><span class="dt">Ordinal</span> n</code> as “variable of <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span>-variate polynomial”.
One can construct ordinals safely by the quasiquoter <a href="http://hackage.haskell.org/package/type-natural/docs/Data-Type-Ordinal-Builtin.html#v:od"><code>od</code></a> provided in <code class="sourceCode haskell"><span class="dt">Data.Type.Ordinal.Builtin</span></code>, when we use <code class="sourceCode haskell"><span class="dt">QuasiQutoes</span></code> language extension.
For example, <code class="sourceCode haskell">[od|3|]</code> stands for the third ordinal.
<code class="sourceCode haskell">[od|3|]<span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">4</span></code> typechecks, but <code class="sourceCode haskell">[od|3|]<span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">2</span></code> is rejected in compile-time<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>The latter function <code class="sourceCode haskell">liftMap</code> seems to have odd type, but it is just an <em>algebraic substitution mapping</em>.
First, <code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Ordinal</span> n <span class="ot">-&gt;</span> <span class="dt">A</span></code> can be seen as “<span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span></span></span>-valued assignment for each variable”.
Then <code class="sourceCode haskell">liftMap f p</code> extends f onto entire polynomial ring <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">R[X_1,\ldots,X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span style="margin-right: 0.00773em;" class="mord mathit">R</span><span class="mopen">[</span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathit">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathit">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span>, just substituting each variables in <code class="sourceCode haskell">p</code> using <code class="sourceCode haskell">f</code> and taking products in <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span></span></span>.
These are what we have calld “the universality of free algebra over commutative rings”, as pictured the following diagram:</p>
<!-- ![Universality of free algebra](images/free-alg-univ.svg )  -->
<p><span class="math display">\[\begin{xy}
\xymatrix @C=10ex @R=15ex {
R[X_1, \ldots, X_n] \ar @{.&gt;}[r]^-{\mathop{\mathtt{liftMap}} f} &amp; A\\
\{X_1, \ldots, X_n\} \ar[u]^{\mathtt{var}} \ar[ur]_{f}
}
\end{xy}\]</span></p>
<p>Although, we can derive other algebraic operations from these two functions in theory, but for the practical purpose, <code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code> class have other algebraic operations as its member functions, which can be overridden by instance-specific optimized implementation.</p>
<h4 id="polynomials-and-monomial-orderings">Polynomials and Monomial Orderings</h4>
<p><code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code> class doesn’t incorporate any information on monomial orderings.
Polynomial rings with operations related monomial orderings is abstracted in <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#t:IsOrderedPolynomial"><code class="sourceCode haskell"><span class="dt">IsOrderedPolynomial</span></code></a>.
This class comes with associated type <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#t:MOrder"><code class="sourceCode haskell"><span class="dt">MOrder</span></code></a>, which stands for the monomial ordering of given polynomial type:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="op">...</span>) <span class="ot">=&gt;</span> <span class="dt">IsOrderedPolynomial</span> (<span class="dt">OrderedPolynomial</span> r <span class="fu">ord</span> n) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">MOrder</span> (<span class="dt">OrderedPolynomial</span> r <span class="fu">ord</span> n) <span class="ot">=</span> <span class="fu">ord</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>This class provide the interfaces to retrieve information related to monomial orderings, such as <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:leadingTerm"><code class="sourceCode haskell">leadingTerm</code></a>, <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:leadingMonomial"><code class="sourceCode haskell">leadingMonomial</code></a> and <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:leadingCoeff"><code class="sourceCode haskell">leadingCoeff</code></a>.</p>
<p>By default, <code>computational-algebra</code> provides the following monomial orderings:</p>
<ul>
<li><a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Lex"><code class="sourceCode haskell"><span class="dt">Lex</span></code></a>, the lexicographical order,</li>
<li><a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Grlex"><code class="sourceCode haskell"><span class="dt">Grlex</span></code></a>, the graded lex order, and</li>
<li><a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Grevlex"><code class="sourceCode haskell"><span class="dt">Grevlex</span></code></a>, the graded reversed lex order.</li>
</ul>
<p>In addition to the basic monomial orders listed above, we can construct new monomial orderings from existing ones with following:</p>
<ul>
<li><a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Graded"><code class="sourceCode haskell"><span class="dt">Graded</span> <span class="fu">ord</span></code></a>, the graded order which first compares the grade (i.e.&nbsp;total degree)
and break the tie with <code class="sourceCode haskell"><span class="fu">ord</span></code>,</li>
<li><a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:ProductOrder"><code class="sourceCode haskell"><span class="dt">ProductOrder</span> n m <span class="fu">ord</span> ord'</code></a>, the product order which compares
first n variables with <code class="sourceCode haskell"><span class="fu">ord</span></code>, then the rest <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span></span></span> variables with <code class="sourceCode haskell">ord'</code>, and</li>
<li><a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:WeightOrder"><code class="sourceCode haskell"><span class="dt">WeightOrder</span> ws <span class="fu">ord</span></code></a>, weighted order which compares the dot-product
with ws first and then break the tie with <code class="sourceCode haskell"><span class="fu">ord</span></code>.</li>
</ul>
<p>We provide the <code class="sourceCode haskell"><span class="dt">Revlex</span></code>, the reversed lex order. <code class="sourceCode haskell"><span class="dt">Revlex</span></code> is <strong>not</strong> the monomial order, but we can construct monomial orderings from it with above constructors. For example, <code class="sourceCode haskell"><span class="dt">Graded</span> <span class="dt">Revlex</span></code> is equivalent to <code class="sourceCode haskell"><span class="dt">Grevlex</span></code>.</p>
<p>Other utility functions and related type-classes are defined in the module <a href="./docs/computational-algebra-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Monomial</span></code></a>.</p>
<h4 id="how-to-write-ismonomialorder-instances">How to write <code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code> instances?</h4>
<p>If you should use the monomial ordering which cannot constructed from the above, and you have proven that ordering is really a monomial ordering, you can just implement an instance for the <code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code>.</p>
<p>In <code class="sourceCode haskell">computational<span class="op">-</span>algebra</code>, monomials are essentially represented as <a href="docs/halg-core-0.6.0.0/Algebra-Internal.html#t:Sized"><code class="sourceCode haskell"><span class="dt">Sized</span> n <span class="dt">Int</span></code></a>, the <code class="sourceCode haskell"><span class="dt">Int</span></code> vector of size <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span> and each <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base"><span style="margin-right: 0.03148em;" class="mord mathit">k</span></span></span></span></span></span>-th element stands for the power of <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base"><span style="margin-right: 0.03148em;" class="mord mathit">k</span></span></span></span></span></span>-th variable.</p>
<p>More precisely, there are two types representing monomials: <code class="sourceCode haskell"><span class="dt">Monomial</span></code> and <code class="sourceCode haskell"><span class="dt">OrderedMonomial</span></code>.
The type <code class="sourceCode haskell"><span class="dt">Monomial</span> n</code> is just a synonym of <code class="sourceCode haskell"><span class="dt">Sized</span> n <span class="dt">Int</span></code>, which is mathematically equal to <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.68889em; vertical-align: 0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">N</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span>.
You can manipulate the value of <code class="sourceCode haskell"><span class="dt">Monomial</span> n</code> with functions provided by <a href="docs/sized-0.2.0.1/Data-Sized-Builtin.html"><code class="sourceCode haskell"><span class="dt">Data.Sized.Builtin</span></code></a> from <a href="http://hackage.haskell.org/package/sized"><code>sized</code> package</a>.</p>
<p><a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:OrderedMonomial"><code class="sourceCode haskell"><span class="dt">OrderedMonomial</span></code></a> is just a newtype wrapping <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Monomial"><code class="sourceCode haskell"><span class="dt">Monomial</span></code></a> tagged with additional monomial ordering information:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">OrderedMonomial</span> <span class="fu">ord</span> n <span class="ot">=</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">OrderedMonomial</span> {<span class="ot"> getMonomial ::</span> <span class="dt">Monomial</span> n }</span></code></pre></div>
<p>Note that type parameter <code class="sourceCode haskell"><span class="fu">ord</span></code> doesn’t appear in the right hand side of its definition.
Such type-parameters are called <em>phantom type</em>s.
The type <code class="sourceCode haskell"><span class="dt">OrderedMonomial</span></code> itself doesn’t incorporate any implementation of monomial ordering, but its phantom type paramter <code class="sourceCode haskell"><span class="fu">ord</span></code> carries such information.</p>
<p>We use <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsOrder"><code class="sourceCode haskell"><span class="dt">IsOrder</span></code></a> classs to retrieve ordering infromation from such pahntom types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IsOrder</span> n <span class="fu">ord</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  cmpMonomial ::</span> <span class="dt">Proxy</span> <span class="fu">ord</span> <span class="ot">-&gt;</span> <span class="dt">Monomial</span> n <span class="ot">-&gt;</span> <span class="dt">Monomial</span> n <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span></code></pre></div>
<p>That is, <code class="sourceCode haskell"><span class="dt">IsOrder</span> n <span class="fu">ord</span></code> stands for the “<code class="sourceCode haskell"><span class="fu">ord</span></code> is ordering on <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.68889em; vertical-align: 0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">N</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span>” and <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#v:cmpMonomial"><code class="sourceCode haskell">cmpMonomial</code></a> is the function to compare two monomials.
The first argument <a href="http://hackage.haskell.org/package/base/docs/Data-Proxy.html#t:Proxy"><code class="sourceCode haskell"><span class="dt">Proxy</span> <span class="fu">ord</span></code></a> is just to indicate “which order to use”, otherwise <code>cmpMonomial</code> can be ambiguous.
For example, we have following instance for <code class="sourceCode haskell"><span class="dt">Lex</span></code> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">IsOrder</span> n <span class="dt">Lex</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  cmpMonomial _ <span class="dt">NilL</span>      <span class="dt">NilL</span>      <span class="ot">=</span> <span class="dt">EQ</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  cmpMonomial _ (n <span class="op">:&lt;</span> ns) (m <span class="op">:&lt;</span> ms)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">&lt;</span> m     <span class="ot">=</span> <span class="dt">LT</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">&gt;</span> m     <span class="ot">=</span> <span class="dt">GT</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> cmpMonomial ns ms</span></code></pre></div>
<p>The type <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Ordering"><code class="sourceCode haskell"><span class="dt">Ordering</span></code></a> is one of the Haskell’s standard data-type which stands for the “comparison result” of two values; that is, <code class="sourceCode haskell"><span class="fu">compare</span> n m</code> returns <code class="sourceCode haskell"><span class="dt">LT</span></code> if <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.5391em;"></span><span class="strut bottom" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="base"><span class="mord mathit">n</span><span class="mrel">&lt;</span><span class="mord mathit">m</span></span></span></span></span></span>, <code class="sourceCode haskell"><span class="dt">GT</span></code> if <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n &gt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.5391em;"></span><span class="strut bottom" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="base"><span class="mord mathit">n</span><span class="mrel">&gt;</span><span class="mord mathit">m</span></span></span></span></span></span> and <code class="sourceCode haskell"><span class="dt">EQ</span></code> if they are equal.
Haskell’s <a href="http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid"><code class="sourceCode haskell"><span class="dt">Monoid</span></code></a> type-class and <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html"><code class="sourceCode haskell"><span class="dt">Data.Ord</span></code></a> module provides more convenient way to write such a comparison function.
For example, we can rewrite above definition as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>cmpMonomial _ ns ms <span class="ot">=</span> <span class="fu">mconcat</span> (zipWithSame <span class="fu">compare</span> ns ms)</span></code></pre></div>
<p>where <a href="docs/sized-0.2.0.1/Data-Sized.html#v:zipWithSame"><code class="sourceCode haskell">zipWithSame</code></a> is imported from <code class="sourceCode haskell"><span class="dt">Data.Sized.Builtin</span></code> from <code>sized</code> package.
Monoid opertions for <code class="sourceCode haskell"><span class="dt">Ordering</span></code> can be considered as left-biased “breaking tie” operator.</p>
<p>The <code class="sourceCode haskell"><span class="dt">Ord</span></code> instance for <code class="sourceCode haskell"><span class="dt">Monomial</span> <span class="fu">ord</span> n</code> is defined if <code class="sourceCode haskell"><span class="dt">IsOrder</span> n <span class="fu">ord</span></code> is defined.
But the above definition only requires <code>ord</code> to be “total order”; it should be monomial ordering to treat do polynomials.
So, if one have proven that some <code>ord</code> is actually a monomial order, one should declare the instance for <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsMonomialOrder"><code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code></a> as below:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsMonomialOrder</span> n <span class="dt">Lex</span></span></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code> doesn’t provide any additional member function, but it is defined to distinguish mere ordering with monomial ordering.
It is instance-implementor’s responsibility to assure that it is really a monomial ordering<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>So in this way, we can define the custom monomial ordering.</p>
<p>There is yet another type-class for monomial orderings: <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsStrongMonomialOrder"><strong><code class="sourceCode haskell"><span class="dt">IsStrongMonomialOrder</span></code></strong></a>.
<code class="sourceCode haskell"><span class="dt">IsOrder</span></code> and <code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code> takes fixed arity as its parameter,
but sometimes we require orderings to work with arbitarary many variables.
If some specific oreder <code>ord</code> has <code>IsMonomialOrder n ord</code> for each <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span>, then GHC automatically generates the instance <code class="sourceCode haskell"><span class="dt">IsStrongMonomialOrder</span> <span class="fu">ord</span></code>.
One can use <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Monomial.html#v:cmpAnyMonomial"><code>cmpAnyMonomial</code></a> function to compare monomials with different arity for such an ordering.</p>
<h3 id="variants-of-polynomial-types">Variants of polynomial types</h3>
<p>There are several polynomial types shipped with this library other than <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span></code>:</p>
<ul>
<li><p><a href="docs/halg-polynomials-0.6.0.0/Algebra-Ring-Polynomial-Univariate.html#t:Unipol"><code class="sourceCode haskell"><span class="dt">Unipol</span> r</code></a> defined in <a href="./docs/computational-algebra-0.6.0.0/Algebra-Ring-Polynomial-Univariate.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Univariate</span></code></a>, which stands for univariate polynomial <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">R[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span style="margin-right: 0.00773em;" class="mord mathit">R</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span></span></span></span></span></span> over some commutative ring <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span style="margin-right: 0.00773em;" class="mord mathit">R</span></span></span></span></span></span>.
It comes with operations optimized to univariate polynomials, such as efficient substitution using <a href="https://en.wikipedia.org/wiki/Horner%27s_method">Horner’s rule</a>
and fast multplication using <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba algorithm</a>.</p></li>
<li><p><a href="docs/halg-polynomials-0.6.0.0/Algebra-Ring-Polynomial-Labeled.html#t:LabPolynomial"><code class="sourceCode haskell"><span class="dt">LabPolynomial</span> poly vars</code></a> defined in <a href="./docs/computational-algebra-0.6.0.0/Algebra-Ring-Polynomial-Labeled.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Labeled</span></code></a>.
It wraps existing polynomial type <code class="sourceCode haskell">poly</code> and have the same operation with it, but it <em>labels</em> each variables in <code class="sourceCode haskell">poly</code> by <code class="sourceCode haskell">vars</code>.
Parameter <code class="sourceCode haskell">vars</code> is the type-level list of unique symbols which have the length equal to the arity of <code class="sourceCode haskell">poly</code> and.
For example:
<code>haskell     LabPolynomial (OrderedPolynomial Rational Grevlex 3) '["x", "y", "z"]</code>
is essentially the same as <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="dv">3</span></code> ,
but each variable is “labeled” with names <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span></span></span>, <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span style="margin-right: 0.03588em;" class="mord mathit">y</span></span></span></span></span></span> and <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span style="margin-right: 0.04398em;" class="mord mathit">z</span></span></span></span></span></span> when we prrety-print values.
By default, the following type-synonym is provided for convenience:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LabPolynomial'</span> r <span class="fu">ord</span> '[x] <span class="ot">=</span> <span class="dt">LabPolynomial</span> (<span class="dt">Unipol</span> r) '[x]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LabPolynomial'</span> r <span class="fu">ord</span> vs   <span class="ot">=</span> <span class="dt">LabPolynomial</span> (<span class="dt">OrderedPolynomial</span> r <span class="fu">ord</span> (<span class="dt">Length</span> vs)) vs</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LabUnipol</span> r x             <span class="ot">=</span> <span class="dt">LabPolynomial</span> (<span class="dt">Unipol</span> r) '[x]</span></code></pre></div>
<p>It also provides strongly-typed inclusion mapping. For exmaple, compiler can statically
generate inclusion mapping from <code class="sourceCode haskell"><span class="dt">LabPolynomial</span> poly '[<span class="st">"x"</span>, <span class="st">"y"</span>, <span class="st">"z"</span>]</code> to
<code class="sourceCode haskell"><span class="dt">LabPolynomial</span> poly '[<span class="st">"z"</span>, <span class="st">"a"</span>, <span class="st">"x"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>]</code>.
Furthermore, with GHC’s <code class="sourceCode haskell"><span class="dt">OverloadedLabels</span></code> extension,
one can use <code class="sourceCode haskell"><span class="pp">#&lt;var&gt;</span></code> syntax to represent variables safely.
For example the following type-checks and we can get what we wanted:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">#x <span class="fu">*</span> #y <span class="fu">-</span> <span class="dv">5</span> <span class="fu">*</span> #a<span class="fu">^</span><span class="dv">2</span><span class="ot"> ::</span> <span class="dt">LabPolynomial'</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="ch">'["a", "x", "y"]</span></code></pre>
<p>And <code class="sourceCode haskell"><span class="ot">#z ::</span> <span class="dt">LabUnipol</span> <span class="dt">Rational</span> <span class="ch">"x"</span></code>
is statically rejected by compiler at compile-time.
One limitation is that we can only use <code>#&lt;var&gt;</code> syntax only for variables starting with small alphabet and whithout any white-spaces.</p></li>
</ul>
<p>Of course, users can define their custom polynomial types and made them instance of <code class="sourceCode haskell"><span class="dt">IsOrdredPolynomial</span></code>.
The module <code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Class</span></code> provides the function <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:injectVars"><code class="sourceCode haskell">injectVars</code></a>, which converts between different polynomial type with the same coefficient, just mapping each variable to corresponding one with the same index in the target.
Sometimes (e.g.&nbsp;variable elimination) one might want to permute variables.
In such a case, you can just use <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:liftMap"><code class="sourceCode haskell">liftMap</code></a>, <a href="docs/halg-core-0.6.0.0/Algebra-Ring-Polynomial-Class.html#v:subst"><code class="sourceCode haskell">subst</code></a> or their variants.</p>
<h3 id="other-polynomial-operations">Other polynomial operations</h3>
<ul>
<li>The module <a href="./docs/computational-algebra-0.6.0.0/Algebra-Ring-Polynomial-Factorise.html"><code>Algebra.Ring.Polynomial.Factorise</code></a> implements the factorisation algorithm for <em>integer-coefficient univariate</em> polynomials.</li>
<li>The module <a href="./docs/computational-algebra-0.6.0.0/Algebra-Algorithms-ZeroDim.html"><code>Algebra.Algorithms.ZeroDim</code></a> provides various algorithms to work with zero-dimensional ideals.</li>
</ul>
<h2 id="provided-algebraic-structures">Provided Algebraic Structures</h2>
<p>This package comes with the following types for algebraic structures:</p>
<ul>
<li><code class="sourceCode haskell"><span class="dt">Integer</span></code> for the ring of integers,</li>
<li><code class="sourceCode haskell"><span class="dt">Rational</span></code> for the rational field,
<ul>
<li><strong>N.B.</strong> <code>computational-algebra</code>’s <code class="sourceCode haskell"><span class="dt">Rational</span></code> is <em>different</em> from the default
<code class="sourceCode haskell"><span class="dt">Rational</span></code> type of Haskell.
This is so because Haskell’s <code class="sourceCode haskell"><span class="dt">Ratio</span> a</code> type requires superfluous constraints
for some algebraic instances.</li>
</ul></li>
<li>Indeed, <code>Rational</code> is a type synonym for <code class="sourceCode haskell"><span class="dt">Fraction</span> <span class="dt">Integer</span></code>,
where <code class="sourceCode haskell"><span class="dt">Fraction</span> r</code> stands for the field of fractions of an integral domain <code>r</code>.</li>
</ul>
<p>Aside from the basic structurs above, we have the following structures: <em>finite fields</em>, <em>quotient rings</em> of polynomial rings, and the field of <em>algebraic reals</em>, which we will describe below.</p>
<h3 id="finite-fields">Finite Fields</h3>
<p><a href="./docs/computational-algebra-0.6.0.0/Algebra-Field-Finite.html"><code class="sourceCode haskell"><span class="dt">Algebra.Field.Finite</span></code></a> provides the type-class for finite fields <a href="docs/halg-core-0.6.0.0/Algebra-Field-Finite.html#t:FiniteField"><code class="sourceCode haskell"><span class="dt">FiniteField</span></code></a> and concrete types for prime field <a href="docs/halg-core-0.6.0.0/Algebra-Field-Finite.html#t:F"><code class="sourceCode haskell"><span class="dt">F</span> p</code></a> which corresponds to <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub><mo>=</mo><mrow><mi mathvariant="double-struck">Z</mi></mrow><mi mathvariant="normal">/</mi><mi>p</mi><mrow><mi mathvariant="double-struck">Z</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{F}_p = \mathbb{Z}/p\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.036108em; vertical-align: -0.286108em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.15139200000000003em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"></span></span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mord">/</span><span class="mord mathit">p</span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span></span></span>.
Note that, this type <em>doesn’t check primarity</em> of type parameter <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span></span></span> (too expensive!).</p>
<p>For other general finite fields other than prime fields (Galois Field), you can use <a href="./docs/computational-algebra-0.6.0.0/Algebra-Field-Galois.html"><code class="sourceCode haskell"><span class="dt">Algebra.Field.Galois</span></code></a> module provides types <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#t:GF"><code class="sourceCode haskell"><span class="dt">GF</span> p n</code></a>, which corresponds to <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.974998em; vertical-align: -0.286108em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.26548em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.5935428571428571em;"><span class="" style="top: -2.786em; margin-right: 0.07142857142857144em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"></span></span></span></span></span></span></span></span></span></span>.
We use <a href="https://en.wikipedia.org/wiki/Conway_polynomial_(finite_fields)">Conway polynomial</a> for internal representation of Galois Fields.
As a default, <code>computational-algebra</code> comes with the information of Conway polynomials for 10th power of 2,3,5,7,11.
Users can easily add the information by just defining <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#t:ConwayPolynomial"><code class="sourceCode haskell"><span class="dt">ConwayPolynomial</span> p n</code></a> instace for specific <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span></span></span> an <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span> as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ConwayPolynomial</span> <span class="dv">19</span> <span class="dv">1</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  conwayPolynomial _ _ <span class="ot">=</span> x <span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">18</span> <span class="op">*</span> x <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> x <span class="ot">=</span> var <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Unipol</span> (<span class="dt">F</span> <span class="dv">19</span>)</span></code></pre></div>
<p>Although we are planning to implement the functionality to automatically calculate Conway Polynomial,
it is recomended to provide concrete value for each specific <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span></span></span> and <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span> to gain the efficiency.
The <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#v:primitive"><code class="sourceCode haskell"><span class="kw">primitive</span></code></a> constant(s) stands for a primitive element of <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.974998em; vertical-align: -0.286108em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.26548em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.5935428571428571em;"><span class="" style="top: -2.786em; margin-right: 0.07142857142857144em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"></span></span></span></span></span></span></span></span></span></span>, i.e.&nbsp;a generator of the multiplicative group <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup><mo>×</mo></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n}^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.811462em;"></span><span class="strut bottom" style="height: 1.17825em; vertical-align: -0.366788em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.811462em;"><span class="" style="top: -2.46932em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.5935428571428571em;"><span class="" style="top: -2.786em; margin-right: 0.07142857142857144em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.1031310000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.366788em;"></span></span></span></span></span></span></span></span></span></span> of units.</p>
<h4 id="galois-field-computation-with-arbitrary-irreducible-polynomials">Galois Field computation with arbitrary irreducible polynomials</h4>
<p>Although Conway polynomials provides systematic way to treat field extensions,
it takes some computational overhead to compute Conway polynomial.
So if one doesn’t need to treat field extension, it is enough to chose arbitrary
irreducible polynomial of degree <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span> with coeffcients in <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.974998em; vertical-align: -0.286108em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.15139200000000003em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"></span></span></span></span></span></span></span></span></span></span> to do computation.</p>
<p>Internally, the type <code class="sourceCode haskell"><span class="dt">GF</span> p n</code> is synonym for <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#t:GF'"><code class="sourceCode haskell"><span class="dt">GF'</span> p n (<span class="dt">Conway</span> p n)</code></a>;
here, <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#t:Conway"><code class="sourceCode haskell"><span class="dt">Conway</span> p n</code></a> is a placeholder to retrieve the information of conway polynomial for <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.974998em; vertical-align: -0.286108em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.26548em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.5935428571428571em;"><span class="" style="top: -2.786em; margin-right: 0.07142857142857144em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"></span></span></span></span></span></span></span></span></span></span>.
Actual computation algorithm for Galios fields is defined for <code class="sourceCode haskell"><span class="dt">GF'</span> p n f</code> for <code class="sourceCode haskell">f</code> carrying information of such an irreducible polynomial.
So if we have some irreducible <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∈</mo><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p \in \mathbb{F}_p[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.036108em; vertical-align: -0.286108em;"></span><span class="base"><span class="mord mathit">p</span><span class="mrel">∈</span><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.15139200000000003em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"></span></span></span></span></span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span></span></span></span></span></span> with <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>deg</mi><mo>⁡</mo><mo>(</mo><mi>p</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\deg(p) = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span class="mop">de<span style="margin-right: 0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">n</span></span></span></span></span></span>, one can compute in <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mi>p</mi><mi>n</mi></msup></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_{p^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.974998em; vertical-align: -0.286108em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.26548em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.5935428571428571em;"><span class="" style="top: -2.786em; margin-right: 0.07142857142857144em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"></span></span></span></span></span></span></span></span></span></span> by <em>reflecting</em> the information of <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span></span></span> to parameter <code class="sourceCode haskell">f</code>.
The <a href="http://hackage.haskell.org/package/reflection"><code>reflection</code> package</a> provides general way to do such a type-level reflection.
Based on that, <code class="sourceCode haskell"><span class="dt">Algebra.Field.Galois</span></code> provides utility function to reflect given irreducible polynomial to type-level: <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#v:withIrreducible"><code class="sourceCode haskell">withIrreducible</code></a>.
Suppose <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∈</mo><msub><mi mathvariant="double-struck">F</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">p \in \mathbb{F}_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.88333em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit">p</span><span class="mrel">∈</span><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span></span></span></span></span></span> is irreducible and <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>deg</mi><mo>⁡</mo><mo>(</mo><mi>p</mi><mo>)</mo><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">\deg(p) = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span class="mop">de<span style="margin-right: 0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord">7</span></span></span></span></span></span>.
Then we can do computation in <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">F</mi><msup><mn>5</mn><mn>7</mn></msup></msub></mrow><annotation encoding="application/x-tex">\mathbb{F}_{5^7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.86651em; vertical-align: -0.17762em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathbb">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.52238em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7463142857142857em;"><span class="" style="top: -2.786em; margin-right: 0.07142857142857144em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.17762em;"></span></span></span></span></span></span></span></span></span></span> as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>withIrreducible p <span class="op">$</span> \pxy <span class="ot">-&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="fu">sqrt</span> (<span class="dv">3</span> <span class="ot">`asProxyTypeOf`</span> pxy))</span></code></pre></div>
<p>In above, <code class="sourceCode haskell">pxy</code> is Proxy type to carry the information of <em>reflected</em> field and <a href="http://hackage.haskell.org/package/base/docs/Data-Proxy.html#v:asProxyTypeOf"><code class="sourceCode haskell">asProxyTypeOf</code></a> forces literals to be interpreted as an element of the reflected field.
One thing to note is that the type variable <code class="sourceCode haskell">f</code> <em>dynamically</em> reflecting polynomial cannot <em>leak</em> outside of given functions.
For example, the value <code class="sourceCode haskell"><span class="dt">GF'</span> p n f</code> itself cannot be taken out from <code class="sourceCode haskell">withIrreducible</code> :</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>withIrreducible p <span class="op">$</span> \pxy <span class="ot">-&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">primitive</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> primivite <span class="op">-</span> <span class="dv">1</span>) <span class="ot">`asProxyTypeOf`</span> pxy <span class="co">-- type error!</span></span></code></pre></div>
<p>In such a situation, one cannot “take out” the reulst directly, but one can still extract the <em>linear representation</em> of it:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>withIrreducible p <span class="op">$</span> \pxy <span class="ot">-&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  linearRepGF (<span class="kw">primitive</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> primivite <span class="op">-</span> <span class="dv">1</span>) <span class="ot">`asProxyTypeOf`</span> pxy) <span class="co">-- OK!</span></span></code></pre></div>
<p>On the other hand, if we adopt Conway polynomials as a representation, one can do any computation without any scope restriction as this.
This is because <code class="sourceCode haskell"><span class="dt">Conway</span> p n</code> carries information of an irreducible polynomial <em>statically</em>.
So you can define <a href="http://hackage.haskell.org/package/reflection/docs/Data-Reflection.html#t:Reifies"><code class="sourceCode haskell"><span class="dt">Reifies</span></code></a> instance for your custom placeholder type and store the information of some specific irreducible polynomial, then you can do such a calculation without any scoping problem:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyPoly</span> <span class="ot">=</span> <span class="dt">MyPoly</span> <span class="co">-- ^ Just for placeholder</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Reifies</span> <span class="dt">MyPoly</span> (<span class="dt">Unipol</span> (<span class="dt">F</span> <span class="dv">5</span>)) <span class="kw">where</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  reflect _ <span class="ot">=</span> x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span> x <span class="op">+</span> <span class="dv">4</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MyGF5'2</span> <span class="ot">=</span> <span class="dt">GF'</span> <span class="dv">5</span> <span class="dv">2</span> <span class="dt">MyPoly</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Also, <code class="sourceCode haskell"><span class="dt">Algebra.Field.Galois</span></code> comes with monadic function <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#v:generateIrreducible"><code class="sourceCode haskell">generateIrreducible</code></a> to find irreducible polynomials and <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#v:reifyGF'"><code class="sourceCode haskell">reifyGF'</code></a> combining these two functions.
There is another function <a href="docs/halg-galois-fields-0.6.0.0/Algebra-Field-Galois.html#v:withGF'"><code class="sourceCode haskell">withGF'</code></a> to retrieve linear representation of elements of Galois Field.
See <a href="./docs/computational-algebra-0.6.0.0/Algebra-Field-Galois.html">documents</a> for more information.</p>
<h3 id="quotient-rings">Quotient rings</h3>
<p>The type <code class="sourceCode haskell"><span class="dt">Quotient</span> k <span class="fu">ord</span> n ideal</code> stands for the quotient ring of n-variate polynomial ring over the field <code class="sourceCode haskell">k</code>.
In order to distinguish the quotient ring over different ideals, we parametrize ideals in type.
We use the functionalities provided by <code class="sourceCode haskell">reflection</code> package here, again.</p>
<h3 id="algebraic-reals">Algebraic Reals</h3>
<p><a href="./docs/computational-algebra-0.6.0.0/Algebra-Field-AlgebraicReal"><code class="sourceCode haskell"><span class="dt">Algebra.Field.AlgebraicReal</span></code></a> module provides the type <a href="./docs/computational-algebra-0.6.0.0/Algebra-Field-AlgebraicReal#t:Algebraic"><code class="sourceCode haskell"><span class="dt">Algebraic</span></code></a> for the field of <em>algebraic reals</em>, i.e.&nbsp;real roots of real coefficient polynomials.</p>
<p>Internally, every algebraic real is represented by the real-coefficient polynomial <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>∈</mo><mrow><mi mathvariant="double-struck">R</mi></mrow><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f \in \mathbb{R}[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span style="margin-right: 0.10764em;" class="mord mathit">f</span><span class="mrel">∈</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mopen">[</span><span style="margin-right: 0.07847em;" class="mord mathit">X</span><span class="mclose">]</span></span></span></span></span></span> and the interval <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>⊆</mo><mrow><mi mathvariant="double-struck">R</mi></mrow></mrow><annotation encoding="application/x-tex">I \subseteq \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68889em;"></span><span class="strut bottom" style="height: 0.82486em; vertical-align: -0.13597em;"></span><span class="base"><span style="margin-right: 0.07847em;" class="mord mathit">I</span><span class="mrel">⊆</span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span></span></span> which contains exactly one real root of <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="base"><span style="margin-right: 0.10764em;" class="mord mathit">f</span></span></span></span></span></span>.</p>
<p>Aside the basic field operations, we currently provide the following operations on algebraic reals:</p>
<ul>
<li><a href="docs/halg-algebraic-0.6.0.0/Algebra-Field-AlgebraicReal.html#v:nthRoot"><code class="sourceCode haskell">nthRoot</code></a>, where <code class="sourceCode haskell">nthRoot n r</code> calculates an <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span></span><sup>th</sup> real root of the given algebraic real <code>r</code>.
If there is no real root, it returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>.</li>
<li><a href="docs/halg-algebraic-0.6.0.0/Algebra-Field-AlgebraicReal.html#v:approximate"><code class="sourceCode haskell">approximate</code></a>: <code class="sourceCode haskell">approximate e r</code> returns an approximating rational number <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span style="margin-right: 0.03588em;" class="mord mathit">q</span></span></span></span></span></span> with <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo><mi>q</mi><mo>−</mo><mi>r</mi><mo>∣</mo><mo>&lt;</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">\lvert q - r \rvert &lt; e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span class="mopen">∣</span><span style="margin-right: 0.03588em;" class="mord mathit">q</span><span class="mbin">−</span><span style="margin-right: 0.02778em;" class="mord mathit">r</span><span class="mclose">∣</span><span class="mrel">&lt;</span><span class="mord mathit">e</span></span></span></span></span></span>.
There is also a type-generic variant <a href="docs/halg-algebraic-0.6.0.0/Algebra-Field-AlgebraicReal.html#v:approxFractional"><code class="sourceCode haskell">approxFractional</code></a>, which returns any <code class="sourceCode haskell"><span class="dt">Fractional</span></code> number (such as <code class="sourceCode haskell"><span class="dt">Double</span></code> or <code class="sourceCode haskell"><span class="dt">Float</span></code> ) instead of <code>Rational</code>.</li>
<li><a href="docs/halg-algebraic-0.6.0.0/Algebra-Field-AlgebraicReal.html#v:realRoots"><code class="sourceCode haskell">realRoots</code></a>: for the univariate polynomial <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="base"><span style="margin-right: 0.10764em;" class="mord mathit">f</span></span></span></span></span></span>, <code class="sourceCode haskell">realRoots f</code> computes all the <em>real</em> roots of <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="base"><span style="margin-right: 0.10764em;" class="mord mathit">f</span></span></span></span></span></span>.
<ul>
<li>There is also <a href="docs/halg-algebraic-0.6.0.0/Algebra-Field-AlgebraicReal.html#v:complexRoots"><code class="sourceCode haskell">complexRoots</code></a> which computes all the <em>complex</em> roots of <span class="math inline"><span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="base"><span style="margin-right: 0.10764em;" class="mord mathit">f</span></span></span></span></span></span>, but it comes with really naive implementation and <em>not ready for the practical usage</em>.</li>
</ul></li>
</ul>
<h2 id="links">Links</h2>
<ul>
<li><a href="./docs/index.html">API Documents</a></li>
</ul>
<h3 id="publication">Publication</h3>
<ul>
<li>Hiromi ISHII, “<a href="https://arxiv.org/abs/1807.01456">A Purely Functional Computer Algebra System Embedded in Haskell</a>”, preprint (to appear in the Proceedings of The 20th International Workshop on Computer Algebra in Scientific Computing (CASC 2018)).</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>One can also construct ordinals using integer literals of Haskell, like <code class="sourceCode haskell"><span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">4</span></code>, but it is unsafe and so highly unrecommended.
For example, although <code class="sourceCode haskell">[od|3|]<span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">2</span></code> is rejected by compiler as expected, but <code class="sourceCode haskell"><span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">2</span></code> passes the compile-time typecheck and throws run-time error.
This is due to the mechanism of Haskell’s literal desugaring.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Indeed, actual implementation is more optimized.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Actually, recent GHC’s type-level functionality is strong enough to
require instances to include static proof of correctness;
but it is too expensive for library writers compared to the result we gain,
hence we haven’t include such “proof requirement” to class.
Another reason is that, it makes difficult to treat <em>dynamically generated orderings</em>,
which occurs in some applications such as integer programming.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Computational Algebra System in Haskell maintained by <a href="https://github.com/konn">konn</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
        <p>Proudedly generated by <a href="http://jaspervdj.be/hakyll/">Hakyll</a>
	, <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> and <a href="https://www.haskell.org">Haskell</a></p>
      </footer>
    </div>
  

</body></html>